Generated by Claude on 6/28/2025 with prompt:
> Write a technical design doc for a web app that will display info about a user's Spotify usage. The front page will allow the user to oauth into Spotify. Then the app will view the user's playlist and find the annual "Your Top Songs" playlists. It will look at the songs from each year and calculate which songs were the most popular across all years based both on appearances in multiple years and the rank in each yearly list. Describe which libraries will be used to interact with Spotify's API, and describe which libraries which will be used for the front end, with mobile use a top priority. Also suggest some efficient, cheap options for hosting the project and possible hosting providers.

# Spotify Analytics Web App - Technical Design Document

## Project Overview

A web application that analyzes a user's Spotify listening history by identifying their annual "Your Top Songs" playlists and calculating which songs were most popular across multiple years based on frequency of appearance and ranking position.

## System Architecture

### High-Level Flow
1. User visits landing page and initiates Spotify OAuth
2. Application retrieves user's playlists via Spotify Web API
3. System identifies annual "Your Top Songs" playlists using pattern matching
4. Application fetches track data from identified playlists
5. Backend calculates cross-year popularity scores
6. Results are displayed in an interactive, mobile-first interface

## Technical Stack

### Frontend Framework
**Next.js 14 with App Router**
- **Rationale**: Server-side rendering for better SEO and initial load performance
- **Mobile-first**: Built-in responsive design patterns and excellent mobile performance
- **OAuth Integration**: Seamless server-side OAuth handling with API routes
- **Deployment**: Optimized for modern hosting platforms

### Styling and UI Components
**Tailwind CSS + shadcn/ui**
- **Tailwind CSS**: Utility-first CSS framework with excellent mobile responsiveness
- **shadcn/ui**: Pre-built, accessible components optimized for mobile
- **Mobile considerations**: Touch-friendly interfaces, proper tap targets, responsive typography

### State Management
**Zustand**
- Lightweight state management perfect for this use case
- Better performance than Redux for smaller applications
- Excellent TypeScript support

### Spotify API Integration
**Primary Library**: `@spotify/web-api-sdk`
- Official Spotify SDK for JavaScript/TypeScript
- Built-in OAuth 2.0 PKCE flow support
- Comprehensive API coverage with TypeScript definitions
- Rate limiting and error handling built-in

**Alternative**: Custom fetch implementation with `node-fetch` (server-side)
- More control over API calls and caching
- Easier to implement custom retry logic

### Authentication
**NextAuth.js v4**
- Built-in Spotify provider
- Secure token management
- Session handling with automatic refresh
- PKCE flow support for enhanced security

## Database Design

### Option 1: Serverless Database
**Vercel KV (Redis) or Upstash Redis**
- Session storage and caching
- Fast read/write for user data
- Pay-per-request pricing

### Option 2: Traditional Database
**PostgreSQL with Prisma ORM**
- Structured data storage for user sessions and cached playlist data
- Strong typing with Prisma
- Good performance for analytical queries

### Schema (if using PostgreSQL)
```sql
-- Users table for session management
users (
  id: uuid PRIMARY KEY,
  spotify_id: varchar UNIQUE,
  access_token: text,
  refresh_token: text,
  created_at: timestamp,
  updated_at: timestamp
)

-- Cached playlist data
playlists (
  id: uuid PRIMARY KEY,
  user_id: uuid REFERENCES users(id),
  spotify_playlist_id: varchar,
  name: varchar,
  year: integer,
  track_data: jsonb,
  last_updated: timestamp
)

-- Calculated song rankings
song_rankings (
  id: uuid PRIMARY KEY,
  user_id: uuid REFERENCES users(id),
  track_id: varchar,
  track_name: varchar,
  artist_name: varchar,
  popularity_score: float,
  years_appeared: integer[],
  average_rank: float,
  calculated_at: timestamp
)
```

## Core Algorithm

### Playlist Identification
```javascript
function identifyTopSongsPlaylists(playlists) {
  const patterns = [
    /your top songs \d{4}/i,
    /top songs of \d{4}/i,
    /\d{4} top tracks/i,
    /wrapped \d{4}/i
  ];
  
  return playlists.filter(playlist => 
    patterns.some(pattern => pattern.test(playlist.name))
  );
}
```

### Popularity Score Calculation
```javascript
function calculatePopularityScore(songAppearances) {
  // Weighted scoring system
  // - Higher weight for multiple year appearances
  // - Inverse weight for ranking position (lower rank = higher score)
  // - Bonus for consistency across years
  
  const yearCount = songAppearances.length;
  const avgRank = songAppearances.reduce((sum, app) => sum + app.rank, 0) / yearCount;
  const rankScore = Math.max(0, 100 - avgRank); // Higher score for better ranks
  const consistencyBonus = yearCount > 1 ? yearCount * 10 : 0;
  
  return (rankScore * yearCount) + consistencyBonus;
}
```

> Here's another score function from Cursor (it said "Tune weights for best results.")
```
  score = (number of years appeared) * weight1 + (sum of (max_rank - rank_in_year)) * weight2
```

## API Design

### Endpoints
```
POST /api/auth/spotify - Initiate Spotify OAuth
GET  /api/auth/callback - Handle OAuth callback
GET  /api/playlists - Fetch user playlists
GET  /api/analysis - Get popularity analysis results
POST /api/refresh - Refresh analysis data
GET  /api/user/profile - Get user profile info
```

### Rate Limiting Strategy
- Implement request queuing for Spotify API calls
- Cache playlist data for 24 hours to reduce API calls
- Use exponential backoff for failed requests
- Batch API requests where possible

## Mobile-First Considerations

### Performance Optimizations
- **Code splitting**: Dynamic imports for non-critical components
- **Image optimization**: Next.js Image component with WebP support
- **Lazy loading**: Intersection Observer for playlist items
- **Progressive loading**: Show basic results first, enhance with details

### UI/UX Mobile Features
- **Touch gestures**: Swipe navigation for year comparisons
- **Responsive charts**: Chart.js or Recharts with mobile-optimized sizing
- **Offline capability**: Service worker for basic functionality
- **Share functionality**: Web Share API for sharing results

## Hosting Options

### Recommended: Vercel (Free tier available)
**Pros:**
- Optimized for Next.js applications
- Global CDN with edge functions
- Automatic HTTPS and custom domains
- Built-in analytics and performance monitoring
- Generous free tier: 100GB bandwidth, unlimited requests

**Pricing:** Free for hobby projects, Pro at $20/month

### Alternative 1: Netlify
**Pros:**
- Good Next.js support with SSR
- Built-in form handling and edge functions
- Free tier: 300 build minutes, 100GB bandwidth
- Easy custom domain setup

**Pricing:** Free tier available, Pro at $19/month

### Alternative 2: Railway
**Pros:**
- Full-stack hosting with database included
- Docker support for custom configurations
- PostgreSQL database included
- Pay-as-you-go pricing

**Pricing:** $5/month base + usage-based

### Budget Option: Cloudflare Pages + Workers
**Pros:**
- Extremely cost-effective
- Global edge network
- Workers for serverless functions
- KV storage for sessions

**Pricing:** Free tier very generous, paid plans start at $5/month

## Database Hosting

### For PostgreSQL:
- **Supabase**: Free tier with 500MB storage, $25/month for production
- **PlanetScale**: Serverless MySQL, free tier available
- **Railway**: Included PostgreSQL with hosting plan

### For Redis/KV:
- **Upstash Redis**: Serverless Redis, free tier 10k requests/day
- **Vercel KV**: Integrated with Vercel hosting

## Security Considerations

### OAuth Security
- Use PKCE flow for enhanced security
- Store tokens securely (httpOnly cookies or secure session storage)
- Implement proper token refresh logic
- Validate all Spotify API responses

### API Security
- Rate limiting on all endpoints
- Input validation and sanitization
- CORS configuration for frontend domains
- Environment variable protection for secrets

## Development Phases

### Phase 1: Core Functionality (MVP)
- Spotify OAuth integration
- Basic playlist fetching and parsing
- Simple popularity calculation
- Mobile-responsive results display

### Phase 2: Enhanced Analytics
- Advanced scoring algorithms
- Year-over-year comparisons
- Export functionality
- Performance optimizations

### Phase 3: Social Features
- Shareable results
- Comparison with friends
- Social media integration
- Enhanced visualizations

## Estimated Costs (Monthly)

### Free Tier Setup:
- Hosting: Vercel/Netlify (Free)
- Database: Supabase/Upstash (Free tier)
- **Total: $0/month** for small user base

### Production Setup:
- Hosting: Vercel Pro ($20)
- Database: Supabase Pro ($25)
- CDN/Monitoring: Included
- **Total: ~$45/month** for production workload

## Performance Targets

- **First Contentful Paint**: < 1.5s on mobile
- **Largest Contentful Paint**: < 2.5s on mobile
- **OAuth Flow**: Complete within 30 seconds
- **Analysis Generation**: < 10 seconds for average user
- **Mobile Lighthouse Score**: > 90 for Performance and Accessibility